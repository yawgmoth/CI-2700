<!DOCTYPE html>
<html>
  <head>
    <title>Lecture 12: 3D graphics</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; font-size: 2em; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      p { font-size: 1.25em; }
      div { font-size: 1.25em; }
      li { font-size: 1.25em; }
      li p { line-height: 1.25em; font-size: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      
      .small li {  font-size: 1em; }
      
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Creaci√≥n de Videojuegos

### 3D Graphics

---

class: center, middle

# Triangles

<div id="tricontainer"></div>

---

# Some definitions

  * Vertex: A point in 3D space
  
  * Triangle: Three vertices
  
  * Face: The "front" side of a triangle
  
  * Normal: A vector that points "away" from the face

---

# Why triangles?

  * Triangles are always flat
  
  * Flat makes it easier to calculate lighting, color, etc.
  
  * Triangles are convex
  
  * Convex makes it easier to interpolate between the vertices
  
  * Any polygon can be divided into triangles 
  
---

# asdf

---

# Cube

<div id="container"></div>


---
class: small

* Triangles 

  - Vertices
  - Color 
  - Normals
  - Interpolation
  
* Meshes 

  - Tesselation
  - obj file format
  - uv mapping
  - Level of Detail
  - Billboards
  

* Rendering pipeline

  - transformations
  - clipping and culling
  - rasterization
  
* Raytracing?



    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/100/three.min.js"></script>
    <script type="text/javascript">
      var slideshow = remark.create({"highlightStyle": "dark"});

      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });

      MathJax.Hub.Configured();
      
    function setupScene(width, height, element)
    {       
        const VIEW_ANGLE = 70;
        const ASPECT = width / height;
        const NEAR = 0.1;
        const FAR = 10000;

        // Get the DOM element to attach to
        const rescontainer =
            document.getElementById(element);
       
        const resrenderer = new THREE.WebGLRenderer();
        const rescamera =
            new THREE.PerspectiveCamera(
                VIEW_ANGLE,
                ASPECT,
                NEAR,
                FAR
            );
            
        rescamera.position.z = 10;
        const resscene = new THREE.Scene();
        resscene.add(rescamera);
        resrenderer.setSize(width, height);

        
        rescontainer.appendChild(resrenderer.domElement);

        const respointLight =
          new THREE.PointLight(0xFFFFFF, 3);

        respointLight.position.x = 0;
        respointLight.position.y = 1;
        respointLight.position.z = 8;
        resscene.add(respointLight);
        var result = {scene: resscene, renderer: resrenderer, camera: rescamera, update: function (object) {} };
        return result;
    }
 
    var cubeinfo = setupScene(window.innerWidth/2, window.innerHeight/2, "container");
    cubeinfo.update = function ( object ) {
            const timer = Date.now() * 0.0001;
            if ( object.isMesh === true ) {
                object.rotation.z = timer * 15;
                object.rotation.x = timer * 22;
            }
        };
    
    var triinfo = setupScene(window.innerWidth/2, window.innerHeight/2, "tricontainer");

    triinfo.update = function ( object ) {
            const timer = Date.now() * 0.0001;
            if ( object.isMesh === true ) {
                object.rotation.y = timer * 6;
            }
        };
  
    
    var tri = new THREE.Geometry();
    
    tri.vertices.push(
        new THREE.Vector3(-2,-2,0), new THREE.Vector3(2,2,0), new THREE.Vector3(2,-2,0)
    );
    
    var triface = new THREE.Face3( 1, 0, 2, new THREE.Vector3(0,0,1), new THREE.Color( 0xff0000 ) );
    
    triface.vertexColors = [ new THREE.Color( 0xff0000 ), new THREE.Color(0x00ff00), new THREE.Color(0x0000ff) ];

    tri.faces.push( triface );
    
    var mat = new THREE.MeshLambertMaterial({vertexColors: THREE.VertexColors, side: THREE.DoubleSide});
    tri.computeVertexNormals();

    var trimesh = new THREE.Mesh(tri, mat);
    triinfo.scene.add(trimesh);    

    
    var cube = new THREE.Geometry();
    
    cube.vertices.push(
        new THREE.Vector3(-2,-2,2), new THREE.Vector3(2,2,2), new THREE.Vector3(2,-2,2), new THREE.Vector3(-2, 2,2),
        new THREE.Vector3(-2,-2,-2), new THREE.Vector3(2,2,-2), new THREE.Vector3(2,-2,-2), new THREE.Vector3(-2, 2,-2)
    );

    cube.faces.push( new THREE.Face3( 1, 0, 2, new THREE.Vector3(0,0,1), new THREE.Color( 0xff0000 ) ), 
                       new THREE.Face3( 0, 1, 3, new THREE.Vector3(0,0,1), new THREE.Color( 0xffaa00 ) ));
                       
    cube.faces.push( new THREE.Face3( 2, 6, 1, new THREE.Vector3(1,0,0), new THREE.Color( 0x00ff00 ) ),
                       new THREE.Face3( 1, 6, 5, new THREE.Vector3(1,0,0), new THREE.Color( 0xffaa00 ) ));
    
    cube.faces.push( new THREE.Face3( 2, 0, 4, new THREE.Vector3(0,-1,0), new THREE.Color( 0xffaa00 ) ),
                       new THREE.Face3( 2, 4, 6, new THREE.Vector3(0,-1,0), new THREE.Color( 0xffaa00 ) ));
                       
    cube.faces.push( new THREE.Face3( 1, 5, 3, new THREE.Vector3(0,1,0), new THREE.Color( 0xffaa00 ) ),
                       new THREE.Face3( 3, 5, 7, new THREE.Vector3(0,1,0), new THREE.Color( 0xffaa00 ) ));
                       
    cube.faces.push( new THREE.Face3( 4, 3, 7, new THREE.Vector3(-1,0,0), new THREE.Color( 0x00ff00 ) ),
                       new THREE.Face3( 0, 3, 4, new THREE.Vector3(-1,0,0), new THREE.Color( 0xffaa00 ) ));
                       
    cube.faces.push( new THREE.Face3( 5, 6, 4, new THREE.Vector3(0,0,1), new THREE.Color( 0xff0000 ) ), 
                       new THREE.Face3( 5, 4, 7, new THREE.Vector3(0,0,1), new THREE.Color( 0xffaa00 ) ));
                       
    cube.computeVertexNormals();
    
    
    var mesh = new THREE.Mesh(cube, mat);

    cubeinfo.scene.add(mesh);
    
    function doUpdate(info)
    {
        info.scene.traverse(info.update);
        info.renderer.render(info.scene, info.camera);
    }

    function update () {
      // Draw!
      doUpdate(cubeinfo);
      doUpdate(triinfo);
      // Schedule the next frame.
      requestAnimationFrame(update);
    }

    // Schedule the first frame.
    requestAnimationFrame(update);
      
    </script>
  </body>
</html>